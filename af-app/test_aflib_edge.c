/**
   Copyright 2019 Afero, Inc.
   This program is a demonstration program that shows you how to capture
   an even from the afero cloud to set an edge attribute, and do something with 
   the data that is sent to you. It also inludes the ability to send a data
   item from the edge device up to the cloud.  This basic functionality is
   really the basis of all communications with the  afero cloud and the device.
   receiving an attribute is typicall used for some kind of control down
   on the device itself. And sending an attribute to the cloud is typically used
   for reporting some kind of operational status from the device back to the
   cloud and mobile app.
*/

// This is a simple unit testing 'EDGED' app, simulating the handling of
// edge attributes (in the hub world) 

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <event2/event.h>
#include <event2/thread.h>
#include <string.h>
#include <errno.h>
#include <signal.h>

#include "af_attr_def.h"
#include "af_attr_client.h" // AF_ATTR_MAX_LISTEN_RANGES
#include "af_log.h"
#include "af_rpc.h"
#include "af_ipc_server.h"
#include "aflib.h"
#include "aflib_mcu.h"
#include "device-description.h"  // the device description file generated by the APE profile editor.

af_lib_t          *sAf_lib    = NULL;  // currently not used in hub aflib
struct event_base *sEventBase = NULL;  // we need really this



// ##############
//
// EDGE ATTRIBUTES (or your APP attributes)
//
// EXAMPLE of handle edge/mcu attributes (which should have been defined in the 
// loaded profile on the device): 
//
// attribute with id 1 : led_button, has value on/off or (1/0)
// attribute with id 2 : represents some kind of state value (uint32)

uint8_t   attr_id_1_led_button = 0;  // attributeId = 5
uint32_t  attr_id_2_state      = 0;  // attributeId = 2

#define DEBUG_ROTATES 1 // comment out to disble logging successes.
#define DEBUG_BIT_COUNTS 1

uint16_t  getdoubled = 0; // value that will get doubled, given to me by the cloud.
uint32_t  doubled    = 0; // value that will get pushed back to the cloud and where the doubling gets deposited.
uint32_t  getrotated = 0; // value that will get rotated right, given to me by the cloud.
uint32_t  rotate    = 0; // to be rotate value goes here, and then gets sent to the cloud.
uint32_t  rotatedr    = 0; // rotated right value goes here, and then gets sent to the cloud.
uint32_t  rotatedl    = 0; // rotated left value goes here, and then gets sent to the cloud.
uint8_t   getadded   = 0; // added to a running sum value. Comes from the cloud.
uint32_t  currentsum = 0; // the current summation value that's sent back to the cloud. Running sum
uint8_t   readvarlog = 0; // used as a bool. set by the cloud. Response is to read var log and send last line.
unsigned char lastlineofvarlog[1536]; // big ole string buffer to respond with.
unsigned char getreversed[1536]; // string sent to us from cloud. must be reversed and sent back..
unsigned char reversed[1536];    // reversed string that is then sent back to the cloud;
uint32_t countbitsofthis = 0; // 32bit integer that we will count the bits that are set to one..
uint8_t  numberofbits = 0; // the result of counting bits in countbitsofthis. This gets sent to cloud.
// END EDGE ATTRIBUTES
// ##############
FILE *sync;  // just a file pointer to rummage through /var/log/messages with.



// EDGED (or your app): this is what you need to program
//
// This callback is executed any time ASR has information for the MCU
// The name of this event is defined in the aflib initialization in setup()
void attrEventCallback(const af_lib_event_type_t eventType,
                       const af_lib_error_t error,
                       const uint16_t attributeId,
                       const uint16_t valueLen,
                       const uint8_t* value) // This value needs to be cast to the correct thing that it is.
  
{
    char hexBuf[80];
    bool set_succeeded = 1;
    uint8_t  ret; 
	      int count=0;
	      int index=0;
	      unsigned char *where;

    
    memset(hexBuf, 0, sizeof(hexBuf));
    if (value != NULL) {
        af_util_convert_data_to_hex_with_name("value", (uint8_t *)value, 
                                          valueLen, hexBuf, sizeof(hexBuf));
    }

    AFLOG_INFO("attrEventCallback:attrid:%d, %s, len=%d", attributeId, hexBuf, valueLen);
    switch (eventType) {
        // Unsolicited notification when a non-MCU attribute changes state
        case AF_LIB_EVENT_ASR_NOTIFICATION: // non-edge attribute notify
            AFLOG_INFO("NOTIFICATION EVENT: for attr=%d", attributeId);

            // TESTING: using the notification of the WIFI_RSSI as triggger to
            //   test af_lib_set_attribute_xx call
            //
            // we are interested in attribute wifi rssi (65005) 
            if (attributeId == AF_ATTR_WIFISTAD_WIFI_RSSI) {
               // TESTING: send attributeId =2, with value=8 up
               //   (simulating an edge attribute is changed and need to do a af_lib_set_xx)
               AFLOG_INFO("EDGED: set_attribute_32() for id=2, value=8");
               attr_id_2_state = 8;
               ret = af_lib_set_attribute_32(sAf_lib, 2, 
                                             attr_id_2_state, AF_LIB_SET_REASON_LOCAL_CHANGE);
               if (ret != AF_SUCCESS) {
                   AFLOG_ERR("af_lib_set_attribute: failed set for the test attributeId=2");
               }
            }
            break;


        case AF_LIB_EVENT_ASR_SET_RESPONSE:
            AFLOG_INFO("ASR_SET_RESPONSE EVENT:");
            break;


        case AF_LIB_EVENT_MCU_SET_REQUEST: // edge attribute set request
            AFLOG_INFO("MCU_SET_REQUEST EVENT: for attr=%d", attributeId);
            // in real world scenario:
            // you would know which attribute by switch on (attributeId) and handle the attributes
            // EDGED/Your app needs to handle 
	    switch( attributeId ){

	    case AF_GETDOUBLED:
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%d",attributeId,(uint32_t)*value);
	      af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&getdoubled); 
	      doubled = (*(uint32_t *)value * 2);
	      AFLOG_INFO( "SET REQUEST for id AF_DOUBLED to %d attempted",doubled);
	      ret = af_lib_set_attribute_32(sAf_lib, AF_DOUBLED, doubled, AF_LIB_SET_REASON_LOCAL_CHANGE);
               if (ret != AF_SUCCESS) {
                   AFLOG_ERR("af_lib_set_attribute: failed set for the test attributeId=2");
               }else
		 AFLOG_INFO("REQUEST: attrib ute id AF_DOUBLED set to %d",doubled);
	      
	      break;

	    case AF_GETROTATED:
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%d",attributeId,*(uint32_t *)value);
	      getrotated = *(uint32_t *)value; // secure the sent data item.
	      rotatedr = (uint32_t)getrotated >> (uint32_t)1; // rotate the bits right by one.
	      getrotated = *(uint32_t *)value; // secure the sent data item.
	      rotatedl = (uint32_t)getrotated << (uint32_t)1; // aaand to the left.
	      // Then say that we received the value
	      af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1,(const uint8_t *) &getrotated);
	      //
	      // doing a name scramble here. Cloud name in ape is ROTATED, 'rotate' is the copy I got from
	      // from the afero stack and then I just copied that value from that attribute into 'rotate'.
	      //
	      //Now I need to create two NEW attributes, but since I know I'll need to I do two things.
	      // mark this section with a TODO: "untie these two directions from rotated and tie
	      // to their own rotatedl and rotatedr attributes. So right now, last one in wins.
	      // NOTE: See if this results in two writes in rapid succession to the cloud or if only the last one
	      // happens.
	      // HOW: to iuntie.. the AF_ROTATED will be AF_ROTATEDR(14) and AF_ROTATEDL(15) and AF_ROTATED will be named AF_ROTATE
	      ret = af_lib_set_attribute_32(sAf_lib, AF_ROTATEDR , (uint32_t)rotatedr, AF_LIB_SET_REASON_LOCAL_CHANGE);
               if (ret != AF_SUCCESS) {
                   AFLOG_ERR("REQUEST:af_lib_set_attribute: failed set for the test attributeId=AF_ROTATEDR");
               }
	       else {
		 AFLOG_ERR("REQUEST: set attribute id AF_ROTATEDR succeeded value = %d.",rotatedr);
	       }
		 
	       ret = af_lib_set_attribute_32(sAf_lib, AF_ROTATEL , (uint32_t)rotatedl, AF_LIB_SET_REASON_LOCAL_CHANGE);
               if (ret != AF_SUCCESS) {
                   AFLOG_ERR("REQUEST:af_lib_set_attribute: failed set for the test attributeId=AG_ROTATEL");
               }
	       else {
		 AFLOG_INFO("REQUEST: set attribute id AF_ROTATEL succeeded value = %d ",rotatedl);
	       }
	      break;

	    case AF_TOGGLELED:
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%d",attributeId,*value);
                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&getadded); 
	      break;

	    case AF_GETADDED:
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%d",attributeId,*(uint8_t *)value);
	      getadded = *(uint8_t *)value; // grab the data given to us.
                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&getadded);
		// Okay, let's use that value.
		currentsum = currentsum + (uint32_t)getadded; // keep it as a running summation.
		//
		//and send a copy to the cloud!
		//
		ret = af_lib_set_attribute_32(sAf_lib, AF_CURRENTSUM, (uint32_t)currentsum, AF_LIB_SET_REASON_LOCAL_CHANGE);
               if (ret != AF_SUCCESS) {
                   AFLOG_ERR("REQUEST:af_lib_set_attribute: failed set for the test attributeId=AF_GETADDED");
               }
	       else {
		 AFLOG_INFO("REQUEST: set attribute id AF_GETADDED succeeded, set to %d.",currentsum);
	       }
	      break;

	    case AF_READVARLOG:
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%d",attributeId,*value);
                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&attr_id_1_led_button); 
		sync = fopen("/var/log/messages", "r");
		if( sync ) { // exists! Let's rummage.
		  while( fgets(lastlineofvarlog, 1024, sync) !=NULL ) {
		    // Just search for the latest line, do nothing in the loop
		  } 
		  AFLOG_INFO("REQUEST: Last line %s\n", lastlineofvarlog); //<this is just a log... you can remove it
		}
		ret = af_lib_set_attribute_str( sAf_lib, AF_LASTLINEOFVARLOG, 1536 ,(const uint8_t *)&lastlineofvarlog[0], AF_LIB_SET_REASON_LOCAL_CHANGE);
		if (ret != AF_SUCCESS) {
		   AFLOG_ERR("REQUEST:af_lib_set_attribute: failed set for the test attributeId=AF_LASTLINEOFVARLOG");
		  }
		  else {
		    AFLOG_INFO("REQUEST: set attribute id LASTLINEOFVARLOG succeeded. set to %s",lastlineofvarlog);
		  }
		  fclose(sync);

		break;

	    case AF_GETREVERSED:
	      count=valueLen; // get the length of the string we are working with.
	      where = value;
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%s",attributeId,value);
	      while( count-- ) getreversed[index++]=*(unsigned char *)where++;
                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)getreversed);
		count = valueLen; // reset counter to size of string - the terminating NULL.
		index = 0; //reset index.
		while( count )reversed[index++] = getreversed[count--];
		reversed[index]='\0';
		ret = af_lib_set_attribute_str( sAf_lib, AF_REVERSED, index ,(const unsigned char *)reversed, AF_LIB_SET_REASON_LOCAL_CHANGE);
                if (ret != AF_SUCCESS) {
                   AFLOG_ERR("REQUEST:af_lib_set_attribute: failed set for the test attributeId=AF_GETREVERSED");
               }

	       else {
		 AFLOG_INFO("REQUEST: set attribute id AF_REVERSED succeeded. set to %s",reversed);
	       }
	      break;

	    case AF_COUNTBITSOFTHIS:
	      AFLOG_INFO( "SET REQUEST for attrId=%d value was=%d",attributeId,*value);
		// Okay, let's use that value.
	      countbitsofthis = *(uint32_t *)value; // keep it here for a bit...
                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&countbitsofthis); 
		numberofbits = 0; // reset the counter.
		//
		// Do the count
		//
		while( countbitsofthis ) // as long as it's not zero.
		  {
		    if( countbitsofthis & 1 ) numberofbits++;
		    countbitsofthis = countbitsofthis >> 1;
		  }
		//
		//and send a copy to the cloud!
		//
	      ret = af_lib_set_attribute_8(sAf_lib, AF_NUMBEROFBITS, numberofbits, AF_LIB_SET_REASON_LOCAL_CHANGE);
                if (ret != AF_SUCCESS) {
                   AFLOG_ERR("REQUEST:af_lib_set_attribute: failed set for the test attributeId=AF_NUMBEROFBITS");
               }
	       else {
		 AFLOG_INFO("REQUEST: set attribute id NUMBEROFBITS succeeded. set to %d",numberofbits);
	       }
	      break;

	    default:
	      AFLOG_INFO( "MCU_SET_REQUEST EVENT UNHANDLED for attr=%d",attributeId);
                set_succeeded = 0;  // failed the set
                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, valueLen, value);

	    }
	    //            if (attributeId == 1) {
	    //                attr_id_1_led_button = *value; 
	    //                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&attr_id_1_led_button); 
	    //            }
	    //            else if (attributeId == 2) {
	    //                attr_id_2_state = *value; 
	    //                AFLOG_INFO("EDGED: new value=%d", attr_id_2_state);
	    //                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, 1, (const uint8_t *)&attr_id_2_state); 
	    //            }
	    //            else {
	    //                // Don't know anything about these attributes, reject
	    //                set_succeeded = 0;  // failed the set
		//                af_lib_send_set_response(sAf_lib, attributeId, set_succeeded, valueLen, value);
	    //            }
            break;


        case AF_LIB_EVENT_MCU_DEFAULT_NOTIFICATION: // edge attribute changed
            AFLOG_INFO("EDGE ATTR changed: for attr=%d", attributeId);
            // You code to handle whatever needs to be done if you are interesed in a particular attribute
            break;


        case AF_LIB_EVENT_ASR_GET_REQUEST: {
            AFLOG_INFO("EDGE ATTR get_reqeust: for attr=%d", attributeId);
            // attribute_store asks for the current value of attribute 
            // (belong to edged or mcu).  Responding with attribute and its value
            // Note 1: af_lib_set_attribute_xx, where xx depends on the type of attributes 

            // Note the following in the call: AF_LIB_SET_REASON_GET_RESPONSE to indicates
            //  it is a reply for the get_request
            if (attributeId == 1) {
                ret = af_lib_set_attribute_8(sAf_lib, attributeId, 
                                             attr_id_1_led_button, AF_LIB_SET_REASON_GET_RESPONSE);
            } 
            else if (attributeId == 2) {
                AFLOG_INFO("af_lib_set_attriubte_32, with AF_LIB_SET_REASON_GET_RESPONSE");
                ret = af_lib_set_attribute_32(sAf_lib, attributeId, 
                                             attr_id_2_state, AF_LIB_SET_REASON_GET_RESPONSE);
            }
            else {
                ret = AF_ERROR_NOT_SUPPORTED;
            }

            if (ret != AF_SUCCESS) {
                AFLOG_ERR("af_lib_set_attribute: failed for request id:%d", attributeId);
            }
            } // AF_LIB_EVENT_ASR_GET_REQUEST
            break;


        default:
           AFLOG_INFO("EVENT: %d, received but not handled", eventType);
           break; 

    } // end switch
}

/* This is the test program to verify aflib implementation */
int main(int argc, char *argv[])
{
    int retVal = AF_SUCCESS;

   /* enable pthreads */
    evthread_use_pthreads();

    /* get an event_base */
    sEventBase = event_base_new();
    /* And make sure we actually got one! */
    if (sEventBase == NULL) {
        /* var/log/messages  entry to show where we are at in this app */
        AFLOG_ERR("main_event_base_new::can't allocate event base");
        retVal = -1;
        return (retVal);
    }

    AFLOG_INFO("EDGE: start");

    /* The event we want to register is the afero library getting data. */
    retVal = af_lib_set_event_base(sEventBase);
    if (retVal != AF_SUCCESS) {
        AFLOG_ERR("main_set_event_base::set event base failed");
        goto err_exit;
    }
 
     
    AFLOG_INFO("EDGE: call af_lib_create_with_unified_callback");
    /*
       Now create the event and point to our callback function when that event
       occurs. Note that this function af_lib_create_with_unified_callback will
       automatically subscribe you to attributes 1 - 1023,  and several wifi, wan and ethernet 
       attributes as well as the profile change attribute.
    */
    sAf_lib = af_lib_create_with_unified_callback(attrEventCallback, NULL);
    if (sAf_lib == NULL) {
        AFLOG_ERR("main_event_base_new::can't allocate event base");
        retVal = -1;
        goto err_exit;
    }
    AFLOG_INFO("EDGE: dispatching event base"); 
    /* start it up! This will not return until
       either there are no more events or the loop exit
       or kill functions are called.
    */
    event_base_dispatch(sEventBase);
   

err_exit:
    // done,let's close/clean up 
    AFLOG_INFO("EDGED:  shutdown");
    af_lib_shutdown();
    return (retVal);
}
